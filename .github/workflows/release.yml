name: release

on:
  workflow_dispatch:
    inputs:
      bump:
        description: 'version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      ref:
        description: 'git ref/branch/sha to release from (optional)'
        required: false
        default: 'main'
        type: string
  issue_comment:
    types: [created]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  # TODO: once https://github.com/Phala-Network/dcap-qvl/pull/113 is merged and a
  # release is published with libdcap_qvl_linux_amd64.a assets, replace the
  # build-dcap-lib job with a simple download from GitHub Releases.
  DCAP_QVL_COMMIT: "c2e89db2fbf98d86be141baf497cd4287388213d"

jobs:
  prepare:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
    outputs:
      should_release: ${{ steps.parse.outputs.should_release }}
      bump: ${{ steps.parse.outputs.bump }}
      target_sha: ${{ steps.parse.outputs.target_sha }}
      source: ${{ steps.parse.outputs.source }}
      repo_lower: ${{ steps.parse.outputs.repo_lower }}
    steps:
      - name: parse trigger
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const eventName = context.eventName
            let shouldRelease = false
            let bump = ''
            let targetSha = ''
            let source = eventName

            if (eventName === 'workflow_dispatch') {
              shouldRelease = true
              bump = (context.payload.inputs?.bump || '').toLowerCase()
              targetSha = context.payload.inputs?.ref || context.ref.replace('refs/heads/', '')
            }

            if (eventName === 'issue_comment') {
              const body = (context.payload.comment?.body || '').trim()
              const match = body.match(/^!release\s+(patch|minor|major)$/i)
              const assoc = context.payload.comment?.author_association || 'NONE'
              const allowed = ['OWNER', 'MEMBER', 'COLLABORATOR']

              if (match && context.payload.issue?.pull_request && allowed.includes(assoc)) {
                const prNumber = context.payload.issue.number
                const pr = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                })
                shouldRelease = true
                bump = match[1].toLowerCase()
                targetSha = pr.data.head.sha
                source = `pr#${prNumber}`
              }
            }

            core.setOutput('should_release', shouldRelease ? 'true' : 'false')
            core.setOutput('bump', bump)
            core.setOutput('target_sha', targetSha)
            core.setOutput('source', source)
            core.setOutput('repo_lower', `${context.repo.owner.toLowerCase()}/${context.repo.repo.toLowerCase()}`)

  create-tag:
    needs: prepare
    if: needs.prepare.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.version.outputs.version }}
      previous_tag: ${{ steps.version.outputs.previous_tag }}
      changelog: ${{ steps.changelog.outputs.changelog }}
    steps:
      - name: checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.target_sha }}
          fetch-depth: 0

      - name: fetch tags
        run: git fetch --tags --force

      - name: compute next version
        id: version
        shell: bash
        run: |
          set -euo pipefail
          latest=$(git tag -l 'v*' --sort=-v:refname | head -n1 || true)
          if [ -z "$latest" ]; then
            latest="v0.0.0"
          fi

          raw="${latest#v}"
          IFS='.' read -r major minor patch <<< "$raw"
          bump="${{ needs.prepare.outputs.bump }}"

          case "$bump" in
            patch)
              patch=$((patch + 1))
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            *)
              echo "invalid bump: $bump" >&2
              exit 1
              ;;
          esac

          next="v${major}.${minor}.${patch}"
          if git rev-parse "$next" >/dev/null 2>&1; then
            echo "tag already exists: $next" >&2
            exit 1
          fi

          echo "version=$next" >> "$GITHUB_OUTPUT"
          echo "previous_tag=$latest" >> "$GITHUB_OUTPUT"

      - name: generate changelog
        id: changelog
        shell: bash
        run: |
          set -euo pipefail
          prev="${{ steps.version.outputs.previous_tag }}"
          if [ "$prev" = "v0.0.0" ] && [ -z "$(git tag -l 'v*')" ]; then
            log=$(git log --pretty=format:'- %s (%h)')
          else
            log=$(git log --pretty=format:'- %s (%h)' "${prev}"..HEAD)
          fi
          if [ -z "$log" ]; then
            log='- no user-facing changes'
          fi
          {
            echo 'changelog<<EOF'
            echo "$log"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: create and push tag
        shell: bash
        run: |
          set -euo pipefail
          version="${{ steps.version.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git tag -a "$version" -m "release $version"
          git push origin "$version"

  build-dcap-lib:
    needs: create-tag
    runs-on: ubuntu-latest
    steps:
      - name: Cache Cargo build
        id: cache-dcap
        uses: actions/cache@v4
        with:
          path: dcap-qvl/target/x86_64-unknown-linux-musl
          key: dcap-lib-musl-${{ env.DCAP_QVL_COMMIT }}

      - name: Build libdcap_qvl.a (musl target for Alpine)
        if: steps.cache-dcap.outputs.cache-hit != 'true'
        run: |
          sudo apt-get update && sudo apt-get install -y musl-tools
          git clone https://github.com/Phala-Network/dcap-qvl.git dcap-qvl
          cd dcap-qvl && git checkout "$DCAP_QVL_COMMIT"
          rustup target add x86_64-unknown-linux-musl
          cargo build --release --features go --target x86_64-unknown-linux-musl

      - name: Upload library artifact
        uses: actions/upload-artifact@v4
        with:
          name: libdcap_qvl
          path: dcap-qvl/target/x86_64-unknown-linux-musl/release/libdcap_qvl.a
          retention-days: 1

  build-and-push:
    needs: [create-tag, build-dcap-lib]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        profile:
          - name: core
            tags: ""
            needs_dcap: false
          - name: ethereum
            tags: "ethereum"
            needs_dcap: false
          - name: solana
            tags: "solana"
            needs_dcap: false
          - name: dcap
            tags: "dcap"
            needs_dcap: true
          - name: full
            tags: "ethereum solana dcap"
            needs_dcap: true
    steps:
      - name: checkout release tag
        uses: actions/checkout@v4
        with:
          ref: refs/tags/${{ needs.create-tag.outputs.version }}

      - name: Download dcap library
        if: matrix.profile.needs_dcap
        uses: actions/download-artifact@v4
        with:
          name: libdcap_qvl
          path: lib

      - name: set up docker buildx
        uses: docker/setup-buildx-action@v3

      - name: login to ghcr
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: set image tags
        id: img
        shell: bash
        run: |
          set -euo pipefail
          repo_name=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          repo="${{ env.REGISTRY }}/${repo_name}"
          version="${{ needs.create-tag.outputs.version }}"
          profile="${{ matrix.profile.name }}"

          tags="${repo}:${version}-${profile},${repo}:latest-${profile}"
          if [ "$profile" = "full" ]; then
            tags="${tags},${repo}:${version},${repo}:latest"
          fi

          echo "tags=$tags" >> "$GITHUB_OUTPUT"

      - name: build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          build-args: |
            GO_BUILD_TAGS=${{ matrix.profile.tags }}
          tags: ${{ steps.img.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  create-release:
    needs: [prepare, create-tag, build-and-push]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: create github release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.create-tag.outputs.version }}
          name: Release ${{ needs.create-tag.outputs.version }}
          body: |
            ## changelog

            ${{ needs.create-tag.outputs.changelog }}

            ## docker images

            ```bash
            docker pull ghcr.io/${{ needs.prepare.outputs.repo_lower }}:${{ needs.create-tag.outputs.version }}-core
            docker pull ghcr.io/${{ needs.prepare.outputs.repo_lower }}:${{ needs.create-tag.outputs.version }}-ethereum
            docker pull ghcr.io/${{ needs.prepare.outputs.repo_lower }}:${{ needs.create-tag.outputs.version }}-solana
            docker pull ghcr.io/${{ needs.prepare.outputs.repo_lower }}:${{ needs.create-tag.outputs.version }}-dcap
            docker pull ghcr.io/${{ needs.prepare.outputs.repo_lower }}:${{ needs.create-tag.outputs.version }}-full
            docker pull ghcr.io/${{ needs.prepare.outputs.repo_lower }}:${{ needs.create-tag.outputs.version }}
            ```

            latest aliases:

            ```bash
            docker pull ghcr.io/${{ needs.prepare.outputs.repo_lower }}:latest-core
            docker pull ghcr.io/${{ needs.prepare.outputs.repo_lower }}:latest-ethereum
            docker pull ghcr.io/${{ needs.prepare.outputs.repo_lower }}:latest-solana
            docker pull ghcr.io/${{ needs.prepare.outputs.repo_lower }}:latest-dcap
            docker pull ghcr.io/${{ needs.prepare.outputs.repo_lower }}:latest-full
            docker pull ghcr.io/${{ needs.prepare.outputs.repo_lower }}:latest
            ```
          make_latest: false
